'''
Created on June, 2015

@author: Léonard Gérard leonard.gerard@sri.com


'''
from radler.astutils.nodetrees import fun_dict_of
from radler.astutils.tools import ensure_dir, write_file
from radler.radlr import infos
from radler.radlr.gen_utils import catkin_pkg
from radler.radlr.rast import AstVisitor, follow_links
from radler.radlr.ros import rosmsg, roscmake, rosutils
from radler.radlr.workspace import ws_rospath


## Machine template running every node of a machine (as local)
# source_file : is the user source file used to generate the plant
# machine_qname : the machine qualname
machine_templates = {
'machine_launchfile':
"""
<!-- Launch file generated by radler from the source file {source_file}
     running locally every node of the machine {machine_qname}
  -->
<launch>
{node_launcher}
</launch>

"""
}

## Node templates to be applied for every node we want to run
# node_name :
# node_package :
# node_executable :

node_templates_machine_sublevel = {
'node_launcher':
'''
  <node name="{node_name}" pkg="{node_package}" type="{node_executable}" output="screen"/>
'''
}


def app(d, templates):
    for (s,t) in templates.items():
        v = t.format(**d)
        if s not in d or not d[s]:
            d[s] = v
        else:
            d[s] += v

def clear(d, templates):
    for s in templates:
        d[s] = ''


def machine(visitor, m, d):
    clear(d, node_templates_machine_sublevel)
    clear(d, machine_templates)
    d['machine_qname'] = str(m._qname)

    visitor.node_bf(m, d)

    app(d, machine_templates)
    filename = d['machine_qname'] + '.launch'
    d['launch_files'].append(filename)
    file = d['package_path'] / filename
    write_file(file, d['machine_launchfile'])



def node(visitor, n, d):
    name = str(n._name)
    d['node_name'] = name
    d['node_executable'] = name #TODO 8: ros backend has many naming issues caused by ROS preventing names to have '.' in them and the fact that we do not want to mangle... The executable name is set by cmake to be the node name...
    app(d, node_templates_machine_sublevel)



def do_pass(plantinfo):
    #TODO 6: actually generate the plant and not everything.
    # For now we generate the plant as if it was a package and put everything inside.
    # The deal is that subscriber needs to know their publishers, so we generate again.
    # We should change it and have actual modular compilation
    # (publisher period, etc being given at exec time to the nodes,
    # with the launch files).


    plant = plantinfo.plant
    ## We first first do like a rospackage but without any dependencies for now.

    package_name = plant._name
    package_folder = ws_rospath(package_name)
    msg_folder = rosutils.msg_folder(package_folder)
    ensure_dir(msg_folder) # Catkin is not happy without a msg folder

    # Generate the package.xml file
    build_deps = ['message_generation', 'message_runtime', 'roscpp', 'radl_lib']
    run_deps = ['message_runtime', 'roscpp']
    # Note that there are no dependencies tsince we generate everything


    catkin_pkg.gen(package_folder, package_name, build_deps, run_deps)

    # Generate the message files
    msg_list = rosmsg.generate_all_msg_files(package_folder, package_name, plant)


    ## Do the actual plant pass to generate the needed launch files.

    d = dict()
    d['source_file'] = str(infos.source_file)
    d['node_package'] = package_name
    v = AstVisitor(fun_dict_of((machine, node)),
                   onleaf=follow_links(AstVisitor.leaf_bf), #@UndefinedVariable
                   kind='bf')
    d['package_path'] = package_folder
    d['launch_files'] = []
    v.visit(plantinfo.plant, d)

    ## Finish generating a self contained package with everything

    # Generate the nodes and cmake file
    def pub_node(t):
        try:
            return plantinfo[t]['publisher_node']
        except KeyError:
            return None
    roscmake.gen(package_folder, msg_list, msg_folder, plant, True, pub_node, extra_files=d['launch_files'])



