'''
Created on Nov, 2014

@author: Léonard Gérard leonard.gerard@sri.com

This file generate the C node wrappers and init processes.

'''

from pathlib import Path

from radler import instrumentation
from radler.astutils.nodetrees import fun_dict_of
from radler.astutils.tools import write_file, uniquelines
from radler.instrumentation import msg_timings
from radler.radlr import infos
from radler.radlr.cgen.cutils import decl_and_def_type
from radler.radlr.errors import internal_error, internal_assert
from radler.radlr.gen_utils import qn
from radler.radlr.gen_utils.user_sources import user_node_class, gather_node_user_file, node_user_header_file, \
    node_sources_type
from radler.radlr.plantgen.channels import kestrel_linux_ipc, kestrel_linux_ip, \
    kestrel_lynxsecureVM_ivc, kestrel_certikosVM_ivc, max_stale_steps
from radler.radlr.rast import AstVisitor, follow_links


## Plant level
#
# plant_ast_package : the package containing the plant's module's ast.
plant_templates = {
'plant_cmake':
'''
cmake_minimum_required(VERSION 2.8.12)
project({plant_dir})

catkin_package()

{machine_dirs}
'''
,
'plant_package':
'''
<package>
  <name>{plant_dir}</name>
  <version>0.0.1</version>
  <description>Generated for plant {plant_name}</description>
  <maintainer email="leonard.gerard@sri.com">Léonard Gérard</maintainer>
  <license>BSD</license>
  <buildtool_depend>catkin</buildtool_depend>
  <build_depend>radl_lib</build_depend>
  <build_depend>kestrel_lib</build_depend>
  <build_depend>{plant_ast_package}</build_depend>
</package>
'''
}

## Machine level machines
#
# machine_dir : the output directory of the machine

machine_templates = {
'machine_cmake':
'''
cmake_minimum_required(VERSION 2.8.12)
{hyp_dirs}
{sys_dirs}
'''}

machine_templates_plant_sublevel = {
'machine_dirs': 'add_subdirectory({machine_dir})\n'
}


##
# Hypervisor level
#
# hyp_dir : the output directory of the hypervisor

lynxsecure_templates = {
'lynxsecure_cmake' :
"""
cmake_minimum_required(VERSION 2.8.12)
{vm_dirs}
"""
}

certikos_templates = {
'certikos_cmake' :
"""
cmake_minimum_required(VERSION 2.8.12)
{vm_dirs}
"""
}


hyp_templates_machine_sublevel = {
'hyp_dirs' : 'add_subdirectory({hyp_dir})\n'
}


##
# Virtual machine level
#
# vm_dir : the output vm directory

vm_templates = {
'vm_cmake' :
"""
cmake_minimum_required(VERSION 2.8.12)
{sys_dirs}
"""
}

vm_templates_hyp_sublevel = {
'vm_dirs' : "add_subdirectory({vm_dir})\n"
,
}



## System level linux/bare_process
#
# sys_dir : The output system directory
# sys_init_target : The cmake target name of the init script
# sys_node_uid : The uid of nodes
# sys_init_h_filename : The name of the file of the generated vm_header_file
# sys_chan_kinds_start_init : calls to kestrel_vm_start_{ipc, ivc, ip}_init();
# sys_chan_kinds_finish_init : calls to kestrel_vm_finish_{ipc, ivc, ip}_init();

sys_linux_templates = {
'sys_init_h_file':
"""
#pragma once
/*
 * File Generated by radler
 *
 */

#include <stdio.h>

#include "kestrel_comm.h"
#include "{plant_ast_header}"


#define _error(msg) {{fprintf(stderr, msg); exit(-1);}}

#ifdef __cplusplus
extern "C" {{
#endif

{chan_extern_decls}
{chan_msg_type_decls}
{chan_msg_type_defs}

{node_main_decls}

#ifdef __cplusplus
}}
#endif
"""
,
'sys_init_c_file':
'''
/*
 * File generated by radler
 *
 */

#include "{sys_init_h_filename}"

{chan_decls}

int main() {{
  pid_t _fork_pid;
  time_t _start_date = radl_to_time_t(radl_gettime());
  printf("\\n===----------\\n"
         "=== Start Time: %s\\n"
         "=== Logging {sys_qname}\\n"
         "===----------\\n", ctime(&_start_date));
  {plant_ast_modinit}();
'''
'{sys_chan_kinds_start_init}'
'{chan_defs}'
'{sys_chan_kinds_finish_init}'
'''
{node_mac_fork}
}}

'''
,
'sys_cmake':
"""
cmake_minimum_required(VERSION 2.8.12)

find_package(catkin REQUIRED radl_lib kestrel_lib {plant_ast_target})

add_definitions(-DIN_RADL_GENERATED_CONTEXT)

add_executable({sys_init_target} {sys_init_c_filename})
target_link_libraries({sys_init_target} ${{catkin_LIBRARIES}} {node_targets})

"""
"{node_targets_definitions}"
"""
"""
}


sys_templates_vm_and_machine_sublevel = {
'sys_dirs' : "add_subdirectory({sys_dir})\n"
,
}

## Node level
#
# node_h_filename : basename of the generated node_h_file
# node_c_filename : basename of the generated node_c_file
# node_user_header : the header file to be included by for the node's user code
# node_user_include_dirs : the dirs to be included
# node_user_src_var : the cmake variable name used to store the node user source folder
# node_user_sources : the user files to be compiled for this node
# node_user_libs : the user libs needed by this node
# node_user_find_libs : the user libs resolving
# node_modulename : the modulename in which this node is
# node_module_init : the node module init function to call
# node_module_lib : the node's module library
# node_state_init : the statements initializing the node's state
# node_step_call : the expression calling the step function
# node_main : this is the nodes main function name
# node_target : this node target name for cmakes
# node_name : this node short name
# node_period : the period of the node
#
# The types of the structures gathering inputs and output mboxes:
#     node_in_struct_type
#     node_in_flags_struct_type
#     node_out_struct_type
#     node_out_flags_struct_type
#


node_templates_sys_sublevel = {
'node_main_decls':
'''
int {node_main}();'''
,
'node_mac_fork':
'''
  // Flush before forking to ensure we are not duplicating outputs
  fflush(stdout);
  fflush(stderr);
  // Fork
  _fork_pid = fork();
  if (_fork_pid == -1) {{
    _error("Fork error");
  }}
  else if (_fork_pid == 0) {{ //In the child, mutate into the node
    if (freopen("radl_{node_qname}.log", "a+", stdout) == NULL)
      _error("Could not create file radl_{node_qname}.log");
    dup2(fileno(stdout), fileno(stderr));
    printf("\\n===----------\\n"
           "=== Start Time: %s\\n"
           "=== Logging {node_qname}, PID %d\\n"
           "===----------\\n", ctime(&_start_date), getpid());
    //TODO unmap unused things ?
    //setuid down
    if (setuid({sys_node_uid}) == -1) _error("Setuid error");
    //run the node
    {node_main}();
    _error("Node {node_qname} main returned (it should never happen).");
  }}
  printf("Created node {node_qname} with PID %d\\n", _fork_pid);
'''
,
'node_targets': "{node_target} "
,
'node_targets_definitions':
"""

# compilation of node {node_qname}
get_target_property({node_user_src_var} {node_module_lib} radl_user_src)"""
"{node_user_find_libs}"
"""
add_library({node_target} STATIC {node_c_filename}{node_user_sources})
target_compile_definitions({node_target}
  PRIVATE RADL_MODULE_NAME={node_modulename}
  PRIVATE RADL_MODULE={node_module_ast_fun}\(\)
  PRIVATE RADL_NODE_NAME={node_name}
  PRIVATE RADL_NODE_QNAME={node_qname}
  PRIVATE RADL_HEADER="{node_h_filename}"
  PRIVATE RADL_STATE={node_user_state_type}
  PRIVATE RADL_STEP_FUN={node_user_step_fun}
  PRIVATE RADL_INIT_FUN={node_user_init_fun}
  PRIVATE RADL_FINISH_FUN={node_user_finish_fun}
)
target_link_libraries({node_target} ${{catkin_LIBRARIES}} {node_module_lib}{node_user_libs})
target_include_directories({node_target} PRIVATE ${{CMAKE_CURRENT_LIST_DIR}}{node_user_include_dirs})

"""
,
'node_source_types' : "{node_source_type}"
}
node_templates = {
'node_c_file':
'''
/*
 * File Generated by radler
 *
 */

#include "kestrel_comm.h"
#include "{sys_init_h_filename}"
#include "{node_h_filename}"
#include "{node_user_header}"
'''
'{chan_updater}'
'{chan_releaser}'
'{chan_staller}'
'{chan_commiter}'
'''

int {node_main}() {{

  {node_module_init}();

  {node_out_struct_type} _out;
  {node_out_flags_struct_type} _out_flags;
  {node_in_struct_type} _in;
  const {node_in_struct_type} * const _pin = &_in;
  {node_in_flags_struct_type} _in_flags;
  const {node_in_flags_struct_type} * const _pin_flags = &_in_flags;
'''
"{node_state_init}"
"{instruments_init}"
'''
  //variable to be used in the loop
  radl_flags_t _gathered_flags;
  int _is_stale;'''
'{solo_pub_init}'
'{chan_init}'
'''

  struct radl_timer_state _timer;
  radl_timer_init(&_timer, {node_period});

  do {{
    _gathered_flags = 0;
'''
'{chan_out_stall}'
'{chan_in_update}'
'{instruments_start}'
'{chan_in_instruments}'
'''
    // Set the flag by default to the gathered input flags
'''
'{pub_set_default_flags}'
'{node_step_call}'
'{instruments_done}'
'{chan_out_instruments}'
'{chan_in_release}'
'{chan_out_commit}'
'{chan_out_poststep}'
'''
    radl_timer_wait(&_timer);
  }}
  while (1);
'''
'{node_state_finish}'
'''
  return 0;
}}

'''
,
'node_h_file':
'''
#pragma once
/*
 * File generated by radler
 *
 * This file has to be included by the user code defining the step function.
 * It defines the input and output structure types to be used.
 *
 * The types are generated with unique mangled names, but the file defines
 * generic names with macros, allowing the step to have the signature:
 * step(const radl_in_t*, const radl_in_flags_t*,
 *      radl_out_t*, radl_out_flags_t*)
 */

#include "radl__lib.h"
#include "{node_module_header}"

typedef struct {{'''
'{pub_struct_def}'
'''
}} {node_out_struct_type};

typedef struct {{'''
'{sub_struct_def}'
'''
}} {node_in_struct_type};

typedef struct {{'''
'{sub_flags_struct_def}'
'''
}} {node_in_flags_struct_type};

typedef struct {{'''
'{pub_flags_struct_def}'
'''
}} {node_out_flags_struct_type};

#undef radl_in_t
#define radl_in_t {node_in_struct_type}

#undef radl_out_t
#define radl_out_t {node_out_struct_type}

#undef radl_in_flags_t
#define radl_in_flags_t {node_in_flags_struct_type}

#undef radl_out_flags_t
#define radl_out_flags_t {node_out_flags_struct_type}

'''
}

## Publisher level

pub_templates_node_sublevel = {
'pub_struct_def':
'''
  {pub_data_type} * {pub_name};'''
,
'pub_flags_struct_def':
'''
  radl_flags_t {pub_name};'''
,
'pub_set_default_flags':
'''    _out_flags.{pub_name} = _gathered_flags;
'''
,
}

solo_pub_templates_node_sublevel = {
'solo_pub_init':
'''
  // {pub_name} publisher is subscriber less.
  {pub_data_type} _localmailbox_{pub_name};
  _out.{pub_name} = &_localmailbox_{pub_name};
'''
}


## Subscriber level

sub_templates_node_sublevel = {
'sub_struct_def':
'''
  const {sub_data_type} * {sub_name};'''
,
'sub_flags_struct_def':
'''
  radl_flags_t {sub_name};'''
}


## Channel level
#
# chan_id : the unique id of the channel
# chan_var : the channel c variable name
# chan_info_var : the channel info c variable name
# chan_kind : the kind of the channel 'ivc', 'ipc' or 'ip'
# chan_data_type : the type of the associated topic
# chan_msg_type : the name of the msg type
# chan_msg_type_decl : the declaration of the msg type
# chan_msg_type_def : the definition of the msg type
# chan_initial_value : the initial value to be put in the channel

chan_templates_sys_sublevel = {
'chan_decls':
'''{chan_kind}_chan_info * {chan_info_var};
'''
,
'chan_extern_decls':
'''extern {chan_kind}_chan_info * {chan_info_var};
'''
,
'chan_msg_type_defs':
'''{chan_msg_type_def}'''
,
'chan_msg_type_decls':
'''{chan_msg_type_decl}'''
,
'chan_kinds_start': '  {chan_kind}_start_init();\n'
,
'chan_kinds_finish': '  {chan_kind}_finish_init();\n'
}

chan_linux_ipc_templates_sys_sublevel = {
'chan_defs':
'''
  {chan_msg_type} _init{chan_var} = {{
    .radl__data = *{chan_initial_value},
    .radl__flags = radl_STALE
  }};
  struct radl_linux_ipc_channel {chan_var} = {{
    .gen_chan = {{
      .id = {chan_id},
      .data_size = sizeof({chan_msg_type}),
      .data_init_value = &_init{chan_var}
    }}
  }};
  {chan_info_var} = kestrel_linux_ipc_init_chan({chan_var});
'''
}

# chan_myvm
# chan_othervm
# chan_region_name
chan_lynxsecure_linuxVM_ivc_templates_sys_sublevel = {
'chan_defs':
'''
  {chan_msg_type} _init{chan_var} = {{
    .radl__data = *{chan_initial_value},
    .radl__flags = radl_STALE
  }};
  struct radl_lynxsecureVM_ivc_channel {chan_var} = {{
    .gen_chan = {{
      .id = {chan_id},
      .data_size = sizeof({chan_msg_type}),
      .data_init_value = &_init{chan_var}
    }},
    .region_name = {chan_region_name}
  }};
  {chan_info_var} = kestrel_lynxsecureVM_ivc_init_chan({chan_var});
'''
}

# chan_myvm
# chan_othervm
chan_certikos_linuxVM_ivc_templates_sys_sublevel = {
'chan_defs':
'''
  {chan_msg_type} _init{chan_var} = {{
    .radl__data = *{chan_initial_value},
    .radl__flags = radl_STALE
  }};
  struct radl_certikosVM_ivc_channel {chan_var} = {{
    .gen_chan = {{
      .id = {chan_id},
      .data_size = sizeof({chan_msg_type}),
      .data_init_value = &_init{chan_var}
    }},
    .my_vm = {chan_myvm},
    .other_vm = {chan_othervm}
  }};
  {chan_info_var} = kestrel_certikosVM_ivc_init_chan({chan_var});
'''
}

# chan_myip
# chan_otherip
chan_linux_ip_templates_sys_sublevel = {
'chan_defs':
'''
  {chan_msg_type} _init{chan_var} = {{
    .radl__data = *{chan_initial_value},
    .radl__flags = radl_STALE
  }};
  struct radl_linux_ip_channel {chan_var} = {{
    .gen_chan = {{
      .id = {chan_id},
      .data_size = sizeof({chan_msg_type}),
      .data_init_value = &_init{chan_var}
    }},
    .my_addr = {chan_myip},
    .other_addr = {chan_otherip}
  }};
  {chan_info_var} = kestrel_linux_ip_init_chan({chan_var});
'''
}


chan_in_templates_node_sublevel = {
'chan_init':
'''
  int _timeout_counter_{chan_id} = 0;'''
,
'chan_updater':
'''
const {chan_msg_type} * _update_{chan_id}(int *stale){{
  //Place to do unmarshaling if ever
  return (const {chan_msg_type} *) {chan_kind}_update({chan_info_var}, stale);
}}
'''
,
'chan_releaser':
'''
void _release_{chan_id}(){{
  {chan_kind}_release({chan_info_var});
}}'''
,
'chan_in_update':
'''
    // Update the status of the {sub_name} mailbox of id {chan_id}
    const {chan_msg_type} * _in_{sub_name} = _update_{chan_id}(&_is_stale);
    _in.{sub_name} = &_in_{sub_name}->radl__data;
    RADL__MNG_FLAGS({sub_name},_in_{sub_name}->radl__flags,_is_stale,_timeout_counter_{chan_id},{chan_mss})

'''
,
'chan_in_release':
'''
    // Release the {sub_name} mailbox
    _release_{chan_id}();

'''
,
'chan_in_instruments':
'''
{chan_in_instrument_hook}
'''
}


master_chan_out_templates_node_sublevel = {
'chan_init':
'''
  /* publication each counter of {pub_name}
   * When equal to 0, time to stall,
   * When equal to {pub_each} - 1, time to commit
   */
  unsigned int _pub_ec_{pub_name} = 0;
  {chan_msg_type} * _out_{chan_id};'''
,
'chan_staller':
'''
{chan_msg_type} * _stall_{chan_id}(){{
  return ({chan_msg_type} *) {chan_kind}_stall({chan_info_var});
}}'''
,
'chan_commiter':
'''
void _commit_{chan_id}(){{
  //Place to do marshaling if ever
  {chan_kind}_commit({chan_info_var});
}}
'''
,
'chan_out_poststep':
'''
    if (_pub_ec_{pub_name} == ({pub_each} - 1)) {{
        _pub_ec_{pub_name} = 0;
    }}
    else {{
        _pub_ec_{pub_name}++;
    }}

'''
,
'chan_out_stall':
'''
    // Stall the master {pub_name} mailbox
    if (_pub_ec_{pub_name} == 0) {{
        _out_{chan_id} = _stall_{chan_id}();
    }}
    _out.{pub_name} = &_out_{chan_id}->radl__data;

'''
,
'chan_out_commit':
'''
    if (_pub_ec_{pub_name} == ({pub_each} - 1)) {{
        // Commit the master {pub_name} mailbox
        // Propagate the flags by putting them in the message
        _out_{chan_id}->radl__flags = _out_flags.{pub_name};
        _commit_{chan_id}();
    }}

'''
,
'chan_out_instruments':
'''
{chan_out_instrument_hook}
'''
}

# master_chan_id

slave_chan_out_templates_node_sublevel = {
'chan_init':
'''
  {chan_msg_type} * _out_{chan_id};
'''
,
'chan_staller':
'''
{chan_msg_type} * _stall_{chan_id}(){{
  return ({chan_msg_type} *) {chan_kind}_stall({chan_info_var});
}}'''
,
'chan_commiter':
'''
void _commit_{chan_id}(){{
  //Place to do marshaling if ever
  {chan_kind}_commit({chan_info_var});
}}
'''
,
'chan_out_stall':
'''
    if (_pub_ec_{pub_name} == 0) {{
        // Stall the slave {pub_name} mailbox
        _out_{chan_id} = _stall_{chan_id}();
    }}

'''
,
'chan_out_commit':
'''
    if (_pub_ec_{pub_name} == ({pub_each} - 1)) {{
        // Commit the slave {pub_name} mailbox
        // Propagate the flags by putting them in the message
        _out_{chan_id}->radl__flags = _out_flags.{pub_name};
        // Copy from the main mailbox
        _out_{chan_id}->radl__data = _out_{master_chan_id}->radl__data;
        _commit_{chan_id}();
    }}

'''
,
'chan_out_instruments':
'''
{chan_out_instrument_hook}
'''
}



def app(d, templates):
    for (s,t) in templates.items():
        v = t.format(**d)
        if s not in d or not d[s]:
            d[s] = v
        else:
            d[s] += v

def clear(d, templates):
    for s in templates:
        d[s] = ''


def _channel(c, d):
    """ Common part for all channels. """
    d['chan_id'] = c.id
    d['chan_direction'] = 'in' if c.incoming else 'out'
    unique_name = d['chan_direction'] + str(c.id)
    d['chan_var'] = '_radl_chan_' + unique_name
    d['chan_info_var'] = 'radlchaninfo_' + unique_name
    d['chan_data_type'] = c.data_typename
    d['chan_initial_value'] = c.data_init_valname
    d['chan_msg_type'] = 'radlchant_' + unique_name
    tdecl, tdef, ddep, ddef = decl_and_def_type(c.msg_type, d['chan_msg_type'])  # @UnusedVariable The dependency should be met since the actual types are of the AST dump -> ddep and ddef are unused
    d['chan_msg_type_def'] = tdef
    d['chan_msg_type_decl'] = tdecl
    if isinstance(c.kind, kestrel_linux_ipc):
        d['chan_kind'] = 'kestrel_linux_ipc'
        app(d, chan_linux_ipc_templates_sys_sublevel)

    elif isinstance(c.kind, kestrel_lynxsecureVM_ivc):
        d['chan_kind'] = 'kestrel_lynxsecureVM_ivc'
        d['chan_region_name'] = '"' + c.kind.region_name + '"'
        app(d, chan_lynxsecure_linuxVM_ivc_templates_sys_sublevel)

    elif isinstance(c.kind, kestrel_certikosVM_ivc):
        d['chan_kind'] = 'kestrel_certikosVM_ivc'
        d['chan_myvm'] = c.kind.myvm
        d['chan_othervm'] = c.kind.othervm
        app(d, chan_certikos_linuxVM_ivc_templates_sys_sublevel)

    elif isinstance(c.kind, kestrel_linux_ip):
        d['chan_kind'] = 'kestrel_linux_ip'
        d['chan_myip'] = '"' + c.kind.myip + '"'
        d['chan_otherip'] = '"' + c.kind.otherip + '"'
        app(d, chan_linux_ip_templates_sys_sublevel)

    app(d, chan_templates_sys_sublevel)


def in_channel(c, d):
    """ for subscribers channel. """
    internal_assert(c.incoming, "in_channel got outgoing channel")
    if infos.instrument_msg_timings:
        d['chan_in_instrument_hook'] = msg_timings.msg_sub_hook(
            d['topic_qname'], d['node_qname'], d['sub_name'], '_in_' + d['sub_name'])
    else:
        d['chan_in_instrument_hook'] = ''
    _channel(c, d)
    d['chan_mss'] = max_stale_steps(int(c.pub['PERIOD']._val),
                                            c.maxlatency,
                                            int(c.sub['PERIOD']._val))

    app(d, chan_in_templates_node_sublevel)

def master_out_channel(c, d):
    """ for the master publisher channel. """
    internal_assert(not c.incoming, "out_channel got incoming channel")
    if infos.instrument_msg_timings:
        d['chan_out_instrument_hook'] = msg_timings.msg_pub_hook(
            d['topic_qname'], d['pub_name'], '_out_' + str(c.id))
    else:
        d['chan_out_instrument_hook'] = ''
    _channel(c, d)
    app(d, master_chan_out_templates_node_sublevel)

def slave_out_channel(c, d):
    """ for the slave publisher channel. """
    internal_assert(not c.incoming, "out_channel got incoming channel")
    _channel(c, d)

    d['chan_out_instrument_hook'] = ''
    if infos.instrument_msg_timings:
        # We need to copy the msg fields from the master publication
        for (f,_) in msg_timings.msg_field_decl():
            s = ('    _out_{c}->{f} = _out_{mc}->{f};\n'
                 ''.format(c=d['chan_id'], f=f, mc=d['master_chan_id']))
            d['chan_out_instrument_hook'] += s

    app(d, slave_chan_out_templates_node_sublevel)


def subscription(sub, d, plantinfo):
    d['sub_name'] = sub._name
    topic = sub['TOPIC']
    d['topic_qname'] = str(topic._qname)
    d['sub_data_type'] = qn.c_typename(topic)
    channels = plantinfo.channels.get(sub, [])
    if len(channels) != 1:
        internal_error(str(sub._qname) + "has " + str(len(channels)) + " incoming channel.")
    in_channel(channels[0], d)
    app(d, sub_templates_node_sublevel)

def publication(pub, d, plantinfo):
    d['pub_name'] = pub._name
    topic = pub['TOPIC']
    d['pub_each'] = pub['EACH']._val if pub['EACH'] else "1"
    d['topic_qname'] = str(topic._qname)
    d['pub_data_type'] = qn.c_typename(topic)
    channels = plantinfo.channels.get(pub, [])
    #Three cases to take into account. 0, 1, + subscribers.
    nbsub = len(channels)
    if nbsub == 0:
        app(d, solo_pub_templates_node_sublevel)
    elif nbsub == 1:
        master_out_channel(channels[0], d)
    else:
        #we take channel[0] as the local mailbox and after step copy to the others.
        masterchan = channels[0]
        master_out_channel(masterchan, d)
        d['master_chan_id'] = masterchan.id
        for c in channels[1:]:
            slave_out_channel(c, d)
    app(d, pub_templates_node_sublevel)

def node(visitor, node, acc):
    d, path, plantinfo = acc
    clear(d, node_templates)
    clear(d, chan_in_templates_node_sublevel)
    clear(d, master_chan_out_templates_node_sublevel)
    clear(d, slave_chan_out_templates_node_sublevel)
    clear(d, pub_templates_node_sublevel)
    clear(d, sub_templates_node_sublevel)
    clear(d, solo_pub_templates_node_sublevel)

    #TODO: 4 solve the issue with this partial naming.
    #since the plant may put together m1.n and m2.n both will be in the same
    #folder and with same filename radl__n.{h,cpp}
    #    Full mangling is possible but a pain for the user if he wants to
    #include the header explicitly.
    #    Maybe radl__m1/n.h would be good and easy for users. In any case
    #the change has to be backported to the ROS backend.
    d['node_h_filename'] = 'radl__' + node._name + '.h'
    node_h_file = path / d['node_h_filename']

    d['node_source_type'] = node_sources_type(node)
    is_c = (d['node_source_type'] == 'C')

    d['node_c_filename'] = 'radl__' + node._name + ('.c' if is_c else '.cpp')
    node_c_file = path / d['node_c_filename']

    nodemodule = node._qname.rootmodule()
    d['node_modulename'] = nodemodule.name()
    d['node_module_init'] = qn.c_modinit(nodemodule)
    d['node_module_header'] = qn.file_ast(nodemodule, '.h')
    d['node_module_lib'] = qn.cmake_ast(nodemodule)
    d['node_module_ast_fun'] = qn.c_astfun(nodemodule)
    d['node_user_state_type'] = qn.c_user_state(node)
    d['node_user_step_fun'] = qn.c_user_step(node)
    d['node_user_init_fun'] = qn.c_user_init(node)
    d['node_user_finish_fun'] = qn.c_user_finish(node)

    if infos.instrumentation:
        d['instruments_init'] = instrumentation.init_hook()
        d['instruments_start'] = instrumentation.step_start_hook()
        d['instruments_done'] = instrumentation.step_done_hook()
    else:
        d['instruments_init']=d['instruments_start']=d['instruments_done'] = ''

    d['node_name'] = node._name
    d['node_qname'] = str(node._qname)

    d['node_target'] = qn.cmake_main(node)

    init, step, finish = user_node_class(node, '_node',
                               '_pin', '_pin_flags', '&_out', '&_out_flags')
    d['node_state_init'] = init
    d['node_step_call'] = step
    d['node_state_finish'] = finish

    d['node_main'] = qn.c_main(node)
    d['node_period'] = node['PERIOD']._val

    d['node_in_struct_type'] = qn.c_kestrel_in_struct(node)
    d['node_out_struct_type'] = qn.c_kestrel_out_struct(node)
    d['node_in_flags_struct_type'] = qn.c_kestrel_inflg_struct(node)
    d['node_out_flags_struct_type'] = qn.c_kestrel_outflg_struct(node)

    for s in node['SUBSCRIBES']:
        subscription(s, d, plantinfo)
    for p in node['PUBLISHES']:
        publication(p, d, plantinfo)

    d['node_user_src_var'] = qn.cmake_user_src(node)
    user_src_path = Path("${" + d['node_user_src_var'] + "}")

    srcs, dirs, libs, find_libs = gather_node_user_file(node, user_src_path)
    d['node_user_include_dirs'] = dirs
    d['node_user_sources'] = srcs
    d['node_user_libs'] = libs
    d['node_user_find_libs'] = find_libs

    d['node_user_header'] = node_user_header_file(node, user_src_path)

    d['node_libs'] = None

    app(d, node_templates_sys_sublevel)
    app(d, node_templates)

    write_file(node_h_file, d['node_h_file'])
    write_file(node_c_file, d['node_c_file'])


## System level

def linux(visitor, li, acc):
    d, path, plantinfo = acc
    clear(d, sys_linux_templates)
    clear(d, node_templates_sys_sublevel)
    clear(d, chan_templates_sys_sublevel)
    clear(d, chan_linux_ipc_templates_sys_sublevel)
    clear(d, chan_certikos_linuxVM_ivc_templates_sys_sublevel)
    clear(d, chan_lynxsecure_linuxVM_ivc_templates_sys_sublevel)
    clear(d, chan_linux_ip_templates_sys_sublevel)

    d['sys_dir'] = li._name
    d['sys_qname'] = str(li._qname)
    path = path / d['sys_dir']

    sys_cmake_file = path / "CMakeLists.txt"
    d['sys_init_target'] = qn.cmake_initproc(li._qname)

    d['sys_node_uid'] = str(li['NODES_UID']._val)

    d['sys_init_h_filename'] = 'radlinit.h'
    sys_h_file = path / d['sys_init_h_filename']

    visitor.node_bf(li, (d, path, plantinfo))

    # We know if we need to compile with c++ once the nodes are visited
    if 'CXX' in d['node_source_types'] :
        sys_ext = '.cpp'
    else:
        sys_ext = '.c'
    d['sys_init_c_filename'] = 'radlinit' + sys_ext
    sys_c_file = path / d['sys_init_c_filename']

    d['sys_chan_kinds_start_init'] = uniquelines(d['chan_kinds_start'])
    d['sys_chan_kinds_finish_init'] = uniquelines(d['chan_kinds_finish'])

    app(d, sys_linux_templates)
    app(d, sys_templates_vm_and_machine_sublevel)

    write_file(sys_h_file, d['sys_init_h_file'])
    write_file(sys_c_file, d['sys_init_c_file'])
    write_file(sys_cmake_file, d['sys_cmake'])


## Virtual machine level

def lynxsecure_vm(visitor, lsvm, acc):
    d, path, plantinfo = acc
    clear(d, vm_templates)
    clear(d, sys_templates_vm_and_machine_sublevel)

    d['vm_kind'] = 'lynxsecure'
    d['vm_dir'] = lsvm._name
    path = path / d['vm_dir']

    vm_cmake_file = path / 'CMakeLists.txt'

    visitor.node_bf(lsvm, (d, path, plantinfo))

    app(d, vm_templates)
    app(d, vm_templates_hyp_sublevel)

    clear(d, sys_templates_vm_and_machine_sublevel)

    write_file(vm_cmake_file, d['vm_cmake'])


def certikos_vm(visitor, cvm, acc):
    d, path, plantinfo = acc
    clear(d, vm_templates)
    clear(d, sys_templates_vm_and_machine_sublevel)

    d['vm_kind'] = 'certikos'
    d['vm_dir'] = cvm._name
    path = path / d['vm_dir']

    vm_cmake_file = path / 'CMakeLists.txt'

    visitor.node_bf(cvm, (d, path, plantinfo))

    app(d, vm_templates)
    app(d, vm_templates_hyp_sublevel)

    clear(d, sys_templates_vm_and_machine_sublevel)

    write_file(vm_cmake_file, d['vm_cmake'])


## Hypervisor level

def lynxsecure(visitor, ly, acc):
    d, path, plantinfo = acc

    clear(d, lynxsecure_templates)
    clear(d, vm_templates_hyp_sublevel)

    d['hyp_dir'] = ly._name
    path = path / d['hyp_dir']
    lynxsecure_cmake_file = path / 'CMakeLists.txt'

    d['hyp_name'] = ly._name

    visitor.node_bf(ly, (d, path, plantinfo))

    app(d, lynxsecure_templates)
    app(d, hyp_templates_machine_sublevel)

    write_file(lynxsecure_cmake_file, d['lynxsecure_cmake'])

def certikos(visitor, c, acc):
    d, path, plantinfo = acc

    clear(d, certikos_templates)
    clear(d, vm_templates_hyp_sublevel)

    d['hyp_dir'] = c._name
    path = path / d['hyp_dir']
    certikos_cmake_file = path / 'CMakeLists.txt'

    d['hyp_name'] = c._name

    visitor.node_bf(c, (d, path, plantinfo))

    app(d, certikos_templates)
    app(d, hyp_templates_machine_sublevel)

    write_file(certikos_cmake_file, d['certikos_cmake'])


## Machine level

def machine(visitor, m, acc):
    d, path, plantinfo = acc

    clear(d, machine_templates)
    clear(d, hyp_templates_machine_sublevel)
    clear(d, sys_templates_vm_and_machine_sublevel)

    d['machine_dir'] = m._name
    path = path / m._name
    machine_cmake_file = path / "CMakeLists.txt"

    visitor.node_bf(m, (d, path, plantinfo))

    app(d, machine_templates)
    app(d, machine_templates_plant_sublevel)

    write_file(machine_cmake_file, d['machine_cmake'])

## Plant level

def plant(visitor, p, acc):
    d, path, plantinfo = acc

    clear(d, plant_templates)
    clear(d, machine_templates_plant_sublevel)

    d['plant_name'] = p._name
    d['plant_dir'] = 'radlplant_' + p._name
    path = path / d['plant_dir']

    plant_cmake_file = path / 'CMakeLists.txt'
    plant_package_file = path / 'package.xml'

    rootmodule = p._qname.rootmodule()
    d['plant_ast_header'] = qn.file_ast(rootmodule, '.h')
    d['plant_ast_modinit'] = qn.c_modinit(rootmodule)
    d['plant_ast_package'] = qn.package_ast(rootmodule)
    d['plant_ast_target'] = qn.cmake_ast(rootmodule)

    visitor.node_bf(p, (d, path, plantinfo))

    app(d, plant_templates)

    write_file(plant_cmake_file, d['plant_cmake'])
    write_file(plant_package_file, d['plant_package'])


def do_pass(plantinfo):
    d = dict()
    path = infos.ws_dir
    v = AstVisitor(fun_dict_of((plant, machine, lynxsecure_vm, lynxsecure,
                                certikos_vm, certikos,
                                linux, node)),
                   onleaf=follow_links(AstVisitor.leaf_bf),  # @UndefinedVariable
                   kind='bf')
    v.visit(plantinfo.plant, (d, path, plantinfo))


