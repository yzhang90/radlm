'''
Created on Sep, 2014

@author: Léonard Gérard leonard.gerard@sri.com

The first goal of this module is to generate a header file with the radl
    user generated types (topics, struct, arrays, etc).

The second goal is to generate a C representation of the a node/AST,
    enabling the user code to access data written in the RADL file,
    like parameters, protocol constants, etc.



There are at least three main concerns:
    - circular definitions of the types but also the values of the AST
    - lists of elements of varying types like  'int/float *'
    - varying types of a same RADL type (list size, optional fields, etc)

%%%%%
1) The 'smartest' version is to create generic enough C types matching radl ones.
This require the use of 'union' and pointers together, making the use of the
dumped value type and array access unsafe (no precise check possible for gcc).

class array
    TYPE string ?
    SIZE int16 ?
    VALUES int16/array*

a1 : array {
    TYPE "int16"
    SIZE 2
    VALUES 8 8
}

--would translate into something like

typedef const char* string_t;
typedef const struct array_t array_t;
struct array_t {
        string_t TYPE;
        int16_t SIZE;
        union array_t_VALUES_u { int16_t int16; array_t * array; } * VALUES;
};

int main(){
        union array_t_VALUES_u vs[] = {8, 8};
        array_t a1 = {
                .TYPE = "int16",
                .SIZE = 2,
                .VALUES = vs,
        };
        array_t * w = vs[0].array; // Type and memory unsafe !!!
}

%%%%%
1 .b) A partial solution would be to add enough information
to allow introspection, allowing the user code to guard itself, but still it
is not safe since nothing really checks in the end.

%%%%%
2) The safest is to generate a type for each value.
Then the genericity of radl class fields is lost (for the good since otherwise
it is unsafe in C). Using then as fields doesn't make sense anymore.
All values inside a class will then be stored flat in the C generated struct,
Fields could then be generated macros or functions (knowing the mapping between
the value names and their radl field membership).


For now, solution 2 is chosen.


We have type declarations stored in infos see typedeclof.

TODO: 6 for now we assume types not to be recursive.

Each node qn gets its type tqn = ctypename(qn) typedefed




RMQ Why not only one big struct:
We cannot generate only one value representing the ast, because we want
Idents and Alias to be transparent. To do that, we need field access to be done
via pointers ('->'), which in turn forces us to allocate the subvalues since the
ast struct type will only contain pointers.

'''

from itertools import chain

from tarjan import tarjan

from radler.radlr import types, infos
from radler.radlr.cgen.cutils import typedeclof, copy_to, decl_and_def_type
from radler.radlr.gen_utils import qn
from radler.radlr.rast import AstVisitor, Ident, Alias
from radler.radlr.types import ArrayType


#TODO: 4 the header file should only contain the const version of types
header_template = """
/**
 * File Generated by radler
**/

#pragma once

#ifdef __cplusplus
extern "C" {{
#endif

#include "radl__lib.h"

{ast_includes}

{header_defsdecls}

void {astinit}();
{asttype}* {astfun}();

#ifdef __cplusplus
}}
#endif

"""

cpp_template = """
/**
 * File Generated by radler
**/

#include "{ast_h_filename}"
{include_user_module_header}

{vdecls}

void {astinit}(){{
  radl_init_lib();
  {includes_init}
  static int initialized = 0;
  if (!initialized){{
    {assgns}
    {post_init_hook}
  }}
  initialized = 1;
}}

{asttype}* {astfun}(){{
  return &{astvalue};
}}

"""


def _add_deps(name_dag, name, deps):
    l = name_dag.get(name, None)
    if l is None:
        name_dag[name] = list(deps)
    else:
        l.extend(deps)

def _is_current_module(node):
    return node._qname.has_root(infos.ast._qname)  # @UndefinedVariable

def collect_node(visitor, node, acc):
    """ We are doing solution 2: forget about class fields,
    the output struct fields are the object variable names.
    This is done depth first to enable sharing of types (CSE of types).
    """
    t = types.of(node)
    name_dag, decls, defs, d = visitor.node_red(node, acc)
    #generate types and declarations
    decl_tname = typedeclof(t)
    tname = qn.c_typename(node)
    if decl_tname is None: #We need to define a type
        tdecl, tdef, decl_deps, def_deps = decl_and_def_type(t, tname)
        decls[tname] = tdecl
        vd = "{} {};\n\n".format(tname, qn.c_varname(node))
        d['vdecls'] += vd
        defs[tname] = tdef + "extern "+ vd
        name_dag[tname] = chain(def_deps, decl_deps)

    elif name_dag.get(tname, None) is None and _is_current_module(node):
        #The type is already defined, only declare it.
        decls[tname] = "typedef {} {};\n".format(decl_tname, tname)
        name_dag[tname] = [decl_tname]
        vd = "{} {};\n\n".format(tname, qn.c_varname(node))
        d['vdecls'] += vd
        defs[tname] = "extern " + vd
    else:
        #The type is defined and declared -> nothing to be done
        return name_dag, decls, defs, d
    #assign the value
    node_assgn = "\n    ".join(copy_to(qn.c_varname(node), node, init=True))
    d['assgns'] += '\n    ' + node_assgn if d['assgns'] else node_assgn
    return name_dag, decls, defs, d

def collect_leaf(visitor, leaf, acc):
    if isinstance(leaf, Alias) and _is_current_module(leaf):
        target = leaf._is_alias_of
        name_dag, decls, defs, d = collect_leaf(visitor, target, acc)
        #assign the value
        t = types.of(target)
        if isinstance(t, ArrayType): #TODO: 5 strange things here..
            node_assgn = "\n    ".join(copy_to(qn.c_varname(leaf), target, False, init=True))
            d['assgns'] += '\n    ' + node_assgn if d['assgns'] else node_assgn
        else:
            d['assgns'] += '\n    '+qn.c_varname(leaf)+' = '+qn.c_varname(target)+';'
        #leaf will have a type already set (._type field of its node)
        #We will do like in col_types_node for nodes with already defined type
        t = types.of(leaf)
        decl_tname = typedeclof(t)
        tname = qn.c_typename(leaf)
        decls[tname] = "typedef {} {};\n".format(decl_tname, tname)
        name_dag[tname] = [decl_tname]
        vd = "{} {};\n\n".format(tname, qn.c_varname(leaf))
        d['vdecls'] += vd
        defs[tname] = "extern " + vd
        return name_dag, decls, defs, d

    elif isinstance(leaf, Ident) and _is_current_module(leaf._node):
        #We only have to generate things for the current module.
        #We are assuming types to not be circular, so easy:
        return collect_node(visitor, leaf._node, acc)
        #RMQ: since we are doing that (depth first), we don't need the name_dag and tarjan.
    else:
        #We have nothing to do, other leafs are basic types
        return acc


def module_settings(visitor, node, acc):
    _,_,_,d = acc
    header = node['HEADER']
    if header:
        d['include_user_module_header'] = '#include "{}"'.format(header._val)
    hook = node['POST_INIT_HOOK']
    if hook:
        d['post_init_hook'] = '{}();'.format(hook._val)
    return collect_node(visitor, node, acc)


def gen(ast):
    name_dag = dict()
    decls = dict()
    defs = dict()
    d = dict({'assgns' : '', 'vdecls' : '', 'include_user_module_header' : '',
         'post_init_hook' : ''})
    visitor = AstVisitor({'module_settings' : module_settings},
                         default=collect_node, onleaf=collect_leaf, kind='red')
    visitor.visit(ast, (name_dag, decls, defs, d))
    names_sccs = tarjan(name_dag)
    d['header_defsdecls'] = ''
    #First declare the types
    for scc in names_sccs:
        #write all typedefs first to allow circular refs
        if len(scc) > 1:
            #For now, since types are not recursive, we should not have scc.
#             internal_error("We have a scc of size {}".format(len(scc)))
            pass
        for tname in scc:
            tdecl = decls.get(tname, None)
            if tdecl:
                d['header_defsdecls'] += tdecl
        #write the definitions
        for tname in scc:
            tdef = defs.get(tname, None)
            if tdef:
                str
                d['header_defsdecls'] += tdef

    d['asttype'] = qn.c_typename(ast)
    d['astvalue'] = qn.c_varname(ast)
    d['astinit'] = qn.c_modinit(ast)
    d['astfun'] = qn.c_astfun(ast)

    d['ast_includes'] = d['includes_init'] = ''
    for n in infos.loaded_modules:
        d['ast_includes'] += '\n#include "{}"'.format(qn.file_ast(n))
        d['includes_init'] += '\n  {}();'.format(qn.c_modinit(n))

    d['ast_h_filename'] = qn.file_ast(ast, '.h')
    d['ast_c_filename'] = qn.file_ast(ast, '.c')

    return (d['ast_c_filename'], cpp_template.format(**d),
            d['ast_h_filename'], header_template.format(**d))




