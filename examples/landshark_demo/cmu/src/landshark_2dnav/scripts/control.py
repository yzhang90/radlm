#!/usr/bin/env python

import ctypes

import roslib #; roslib.load_manifest('rbx1_nav')
import rospy

import actionlib
from actionlib_msgs.msg import *
from geometry_msgs.msg import Pose, PoseStamped, PoseWithCovarianceStamped, PointStamped, TwistStamped
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal

from landshark_2dnav.msg import LocalPPAction, LocalPPGoal
from std_msgs.msg import UInt8
from nav_msgs.msg import Path

from nav_msgs.srv import GetPlan

class Nav():
  def __init__(self):
    rospy.init_node('landshark_2dnav_control')
# get plan without running move_base local_pp
    self.make_plan = rospy.ServiceProxy('/move_base/NavfnROS/make_plan', GetPlan)
    rospy.wait_for_service('move_base/make_plan')
# publish the plan generated by move_base/make_plan
    self.msgPlanEmpty = Path
    self.pubPlan = rospy.Publisher('landshark_2dnav/plan', Path, queue_size=10)
# global_pp status for RADL to pp_gateway
    self.msgPPStatus = UInt8()
    self.pubPPStatus = rospy.Publisher('landshark_2dnav/pp_status', UInt8, queue_size=10)
# OFF, ON, ENGAGED, FAILURE, TRYING, GOAL_SUCCESS, GOAL_FAIL 
    self.msgPPStatus.data = 0 #ctypes.c_uint8(1)
    self.pubPPStatus.publish(self.msgPPStatus)
# for Local PP. Sends the Path created by move_base/make_plan
    self.localPPGoal = LocalPPGoal()
    self.localPP = actionlib.SimpleActionClient('/landshark_2dnav/local_pp/start', LocalPPAction)
    rospy.loginfo("waiting for local_pp SimpleActionClient")
    self.localPP.wait_for_server()
# BaseVelocity is sent to pp_gateway
    self.pubBaseVelocity = rospy.Publisher('/landshark_2dnav/base_velocity', TwistStamped, queue_size=10)
# get from pp_gateway
    self.subPPRequest = rospy.Subscriber('/radl/pp_request',UInt8,self.getPPRequest)
# get goal_meters from landshark_gps_meters_node
    self.subGoalMeters = rospy.Subscriber('/landshark/goal_meters',PointStamped,self.getGoalMeters)
    self.msgGoalMeters = PointStamped
# get robot current position
    rospy.Subscriber('/landshark/gps_meters', PointStamped, self.getGpsMeters)
    self.msgGpsMeters = PointStamped
# get plan created by move_base/make_plan to send to local_pp
    self.path = []
# pub pp_status to pp_gateway and path from move_base/make_plan
    r = rospy.Rate(10)
    while not rospy.is_shutdown():
      self.pubPPStatus.publish(self.msgPPStatus)
      if hasattr(self.path, 'poses'):
        self.pubPlan.publish(self.path)
      r.sleep()
    rospy.on_shutdown(self.shutdown)

  def getGpsMeters(self, msg):
    self.msgGpsMeters = msg

  def getGoalMeters(self,msg):
    self.msgGoalMeters = msg

  def getPPRequest(self,msg):
    self.msgPPRequest = msg
    if self.msgPPRequest.data==1:
      rospy.loginfo("start global and local pp")
      self.NavControl()
    elif self.msgPPRequest.data==2:
# reset path to empty
      self.path = []
      rospy.loginfo("cancel local pp")
      self.localPP.cancel_goal()
#      rospy.sleep(1)
      self.pubBaseVelocity.publish(TwistStamped())
      self.msgPPStatus.data = 0

  def NavControl(self):
    rospy.loginfo("NavController")
# A variable to hold the initial pose of the robot to be set by the user in RViz
    self.initial_pose = PoseWithCovarianceStamped()  

# Set up the next goal location
    start = PoseStamped()
    start.header.frame_id = "/map"
    goal = PoseStamped()
    goal.header.frame_id = "/map"
    tolerance = 0.0
    start.pose.position.x = self.msgGpsMeters.point.x
    start.pose.position.y = self.msgGpsMeters.point.y
    goal.pose.position.x = self.msgGoalMeters.point.x
    goal.pose.position.y = self.msgGoalMeters.point.y

    rospy.loginfo("move_base/make_plan")
    plan_response = self.make_plan(start = start, goal = goal, tolerance = tolerance)
    if len(plan_response.plan.poses) > 0: #hasattr(plan_response.plan, 'poses'):
# Let the user know where the robot is going next
      rospy.loginfo("Going to: " + str(self.msgGoalMeters.point.x) + ", " + str(self.msgGoalMeters.point.y))
      self.path = plan_response.plan
      self.localPPGoal.path.poses = self.path.poses
      rospy.loginfo('localPPStart')
      self.localPP.send_goal(self.localPPGoal)
# OFF, ON, ENGAGED, FAILURE, TRYING, GOAL_SUCCESS, GOAL_FAIL 
      self.msgPPStatus.data = 2
      return
    else:
      rospy.logerr('global path not found')
      self.msgPPStatus.data = 3
      return
# Allow 5 minutes to get there
    self.finished_within_time = self.localPP.wait_for_result(rospy.Duration(300)) #possible FIX ME
    if self.finished_within_time:
      rospy.loginfo("global and local pp success")
#OFF, ON, ENGAGED, FAILURE, TRYING, GOAL_SUCCESS, GOAL_FAIL 
      self.msgPPStatus.data = 0
    else:
      rospy.logerr("failed to reach goal in time")
#OFF, ON, ENGAGED, FAILURE, TRYING, GOAL_SUCCESS, GOAL_FAIL 
      self.msgPPStatus.data = 3
    print "self.localPP.get_result() = ", self.localPP.get_result()  # move_base result   

  def shutdown(self):
    rospy.loginfo("Stopping the robot...")
    self.localPP.cancel_goal()
    rospy.sleep(1)
    self.pubBaseVelocity.publish(TwistStamped())
    rospy.sleep(1)
#OFF, ON, ENGAGED, FAILURE, TRYING, GOAL_SUCCESS, GOAL_FAIL 
    self.msgPPStatus.data = 0
    self.pubPPStatus.publish(self.msgPPStatus)

if __name__ == '__main__':
  try:
    Nav()
  except rospy.ROSInterruptException:
    rospy.loginfo("landshark_2dnav failed")
