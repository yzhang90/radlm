/*Most simple DMC Teriminal Program.  No need to list/choose controller,   Only 1 PCI controller is used.  7/27/2000  Terminal Program, YJ.Sun, Vers. 1.0 8/2000[root@localhost galil]# gcc -g -Wall term.c dmclnxlib/dmclnx.a -Idmclnxlib -oterm[root@localhost galil]# ./termGalil Terminal Program for Linux Ver. 1.1.0Galil Motion Control Inc. 7/2000Please specify which type of controller you are using1  for PCI controllers2  for ETHERNET controllers1Connected.  Ctrl-C to exit.:^R^VDMC1886 Rev 1.0:MG_BN 1.0000:Thank you for using Galil![root@localhost galil]#               */#include <fcntl.h>#include <termios.h>#include <unistd.h>#include "dmclnx.h"#include "dmcdrc.h"void PrintError(long rc){ 	printf("An error has occurred. Return code = %ld\n", rc);  	fflush(stdout);}void listerror(){	printf("List of all the API error codes: \n\n");	printf("-1    Timeout Error       -2    Command Error\n");	printf("-3    Controller Error    -4    File Error\n");	printf("-5    Driver Error           -6   Handle Error\n");	printf("-7    HModule Error	 -8    Memory Error\n");	printf("-9    Buffer Full Error    -10  ResponseData Error\n");	printf("-11  DMA Error              -12   Argument Error\n");	printf("-13  Data Record Error  -14   Download Error\n");	printf("-15  Firmware Error      -16   Conversion Error\n");	printf("-17  Resource Error       -18   Registry Error\n");	printf("-19  Controller Busy      -20   Device Disconnectted\n");}int main(int argc, char* argv[]){	int            temp;	long           rc = 0;      // Return code	char           buffer[256] = "";  // Response from controller	HANDLEDMC      hdmc = -1;         // Handle to controller	CONTROLLERINFO controllerinfo;    // Controller information structure	char           tempchar[4];	long           timeout=1000;	char           filename[32];	char		  uresponse[256];	int 		 n = 0, s;	ULONG	ibytes, obytes;	fd_set 	rdfd;	struct termios tc, oldTC;	struct timeval timeout1 = {0, 100000};	int 		ctype;	char    	ipaddress[32];	argc = argc;	argv = argv;	printf("Galil Terminal Program for Linux Ver. 1.1.0\n\n");	printf("Galil Motion Control Inc. 7/2000\n\n");	memset(&controllerinfo, '\0', sizeof(controllerinfo));	printf("Please specify which type of controller you are using \n\n");	printf("1  for PCI controllers\n");	//printf("2  for ISA controllers\n");	printf("2  for ETHERNET controllers\n");	//	printf("4  for SERIAL controllers\n");	scanf("%d", &ctype);	switch(ctype)	{		case 1:			controllerinfo.cbSize = sizeof(controllerinfo);			controllerinfo.usModelID = MODEL_1802;			controllerinfo.fControllerType = ControllerTypePCIBus;			controllerinfo.ulTimeout = 1000;			controllerinfo.hardwareinfo.businfo.fDataRecordAccess = DataRecordAccessFIFO;			break;/*		case 2:			controllerinfo.cbSize = sizeof(controllerinfo);			controllerinfo.usModelID = MODEL_1700;			controllerinfo.fControllerType = ControllerTypeISABus;			controllerinfo.ulTimeout = 1000;			controllerinfo.hardwareinfo.businfo.fDataRecordAccess = DataRecordAccessFIFO;			break;*/		case 2:			printf("Please specify IP address:\n");			scanf("%s", ipaddress);			controllerinfo.cbSize = sizeof(controllerinfo);   			controllerinfo.usModelID = MODEL_2100;   			controllerinfo.fControllerType = ControllerTypeEthernet;   			controllerinfo.ulTimeout = 1000;   			controllerinfo.ulDelay = 5;   			controllerinfo.hardwareinfo.socketinfo.fProtocol = EthernetProtocolTCP;   			strcpy(controllerinfo.hardwareinfo.socketinfo.szIPAddress, ipaddress);   			break;   	default:			printf("No controller specified, End the program. \n");			return -1;	}; //switch(ctype)	DMCInitLibrary();	// Open the connection	rc = DMCOpen( &controllerinfo, &hdmc );	if (rc)	{		PrintError(rc);      return rc;	}   else      printf("Connected.  Ctrl-C to exit.\n"); 	rc = DMCGetTimeout(hdmc, &timeout);	if (rc)      PrintError(rc);	tcgetattr(0, &tc);	oldTC = tc;	cfmakeraw(&tc);	tcsetattr(0, TCSANOW, &tc);	FD_ZERO(&rdfd);	while (1)   {		rc = DMCGetUnsolicitedResponse(hdmc, uresponse, sizeof(uresponse));	  	if (rc)	  		PrintError(rc);	  	else if(strcmp(uresponse, "") != 0)	  		printf("%s \n", uresponse);	  	FD_SET(0, &rdfd);	  	s = select(1, &rdfd, 0, 0, &timeout1);	  	if (FD_ISSET(0, &rdfd) )	  	{	  		s = read(0,  &tempchar[n], 1);	  		         switch (tempchar[n])	  		{	  			case 3:	//CTRL-C, STOP PROGRAM	  				tcsetattr(0, TCSANOW, &oldTC);	  				rc = DMCClose(hdmc);					if (rc)					{  						PrintError(rc);  						return rc;					}					printf("\nThank you for using Galil!\n");					return 0L;					break;				case 4:     //CTRL-D download file					tcsetattr(0, TCSANOW, &oldTC);					printf("Input file directory/name for download: \n");					scanf("%s",filename);					rc=DMCDownloadFile(hdmc, filename, NULL);					if (rc) PrintError(rc);					tcsetattr(0, TCSANOW, &tc);					n = 0;					break;				            case 5:    	//CTRL-E list error codes					tcsetattr(0, TCSANOW, &oldTC);					listerror();					tcsetattr(0,TCSANOW,&tc);					break;				case 6:    //CTRL-F, send file					tcsetattr(0, TCSANOW, &oldTC);					printf("Input file directory/name to send: \n");					scanf("%s",filename);					rc=DMCSendFile(hdmc, filename);					if (rc) PrintError(rc);					tcsetattr(0, TCSANOW, &tc);					n = 0;					break;				case 8:     //CTRL-H, help					tcsetattr(0, TCSANOW, &oldTC);					printf("Linux Terminal Program, Version 1.0, 8/2000\n\n");					printf("Help:  Extra Function Keys:\n\n");					printf("^D for download file\n\n");					printf("^E for displaying API error codes\n");					printf("F for sending DMC File to controller\n");					printf("^T for setting timeout\n");					printf("^C to quit the program\n");					tcsetattr(0, TCSANOW, &tc);					n = 0;					break;	  			case 13:	//RETURN	  				tempchar[n]='\r';	  				rc = DMCWriteData(hdmc, tempchar, n + 1, &ibytes);	  				write(1,"\r\n",2);	  				               if (rc){ PrintError(rc);}	  				n = 0;	  				break;	  			case 20:   //CTRL-T for timeout	  				tcsetattr(0, TCSANOW, &oldTC);	  				printf("The current timeout used is %li ms\n", timeout);	  				printf("Input new timeout, -1 to cancel: ");	  				scanf("%d", &temp);	  				if (temp >= 0){	  					timeout = temp;	  					rc = DMCSetTimeout(hdmc, timeout);						if (rc) PrintError (rc);					}					break;				case 0x7f:  //DEL/					if (n) {						write(1, "\b \b", 3);						n--;					}					               break;	  			default :	  				if (tempchar[n] == 18) write(1, "^R", 2);	  				if (tempchar[n] == 19) write(1, "^S", 2);	  				if (tempchar[n] == 22) write(1, "^V", 2);	  				write(1, &tempchar[n], 1);	  				n++;	  		} //switch (tempchar[n])	  	} //if (FD_ISSET(0, &rdfd) )		usleep (timeout);	  	rc = DMCReadData(hdmc, buffer, sizeof(buffer), &obytes);	  	if (rc)         PrintError(rc);	  	if (obytes > 0)      {	  	  	write (1, buffer, obytes);	  	  	strcpy(buffer,"");		}	}    //while (1)	rc = DMCClose(hdmc);	if (rc)	{	  PrintError(rc);	  return rc;	}	printf("\nDone\n");	   return 0L;} //int main(int argc, char* argv[])