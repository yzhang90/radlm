// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ocu.proto

#ifndef PROTOBUF_ocu_2eproto__INCLUDED
#define PROTOBUF_ocu_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ocu {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ocu_2eproto();
void protobuf_AssignDesc_ocu_2eproto();
void protobuf_ShutdownFile_ocu_2eproto();

class Status;
class Command;
class Point;
class Map;

// ===================================================================

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 seq = 21;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 21;
  inline ::google::protobuf::uint64 seq() const;
  inline void set_seq(::google::protobuf::uint64 value);

  // optional string fsm_actuator = 22;
  inline bool has_fsm_actuator() const;
  inline void clear_fsm_actuator();
  static const int kFsmActuatorFieldNumber = 22;
  inline const ::std::string& fsm_actuator() const;
  inline void set_fsm_actuator(const ::std::string& value);
  inline void set_fsm_actuator(const char* value);
  inline void set_fsm_actuator(const char* value, size_t size);
  inline ::std::string* mutable_fsm_actuator();
  inline ::std::string* release_fsm_actuator();
  inline void set_allocated_fsm_actuator(::std::string* fsm_actuator);

  // optional string fsm_status = 23;
  inline bool has_fsm_status() const;
  inline void clear_fsm_status();
  static const int kFsmStatusFieldNumber = 23;
  inline const ::std::string& fsm_status() const;
  inline void set_fsm_status(const ::std::string& value);
  inline void set_fsm_status(const char* value);
  inline void set_fsm_status(const char* value, size_t size);
  inline ::std::string* mutable_fsm_status();
  inline ::std::string* release_fsm_status();
  inline void set_allocated_fsm_status(::std::string* fsm_status);

  // optional string base_status = 24;
  inline bool has_base_status() const;
  inline void clear_base_status();
  static const int kBaseStatusFieldNumber = 24;
  inline const ::std::string& base_status() const;
  inline void set_base_status(const ::std::string& value);
  inline void set_base_status(const char* value);
  inline void set_base_status(const char* value, size_t size);
  inline ::std::string* mutable_base_status();
  inline ::std::string* release_base_status();
  inline void set_allocated_base_status(::std::string* base_status);

  // optional string actuator_status = 25;
  inline bool has_actuator_status() const;
  inline void clear_actuator_status();
  static const int kActuatorStatusFieldNumber = 25;
  inline const ::std::string& actuator_status() const;
  inline void set_actuator_status(const ::std::string& value);
  inline void set_actuator_status(const char* value);
  inline void set_actuator_status(const char* value, size_t size);
  inline ::std::string* mutable_actuator_status();
  inline ::std::string* release_actuator_status();
  inline void set_allocated_actuator_status(::std::string* actuator_status);

  // optional string rse_status = 26;
  inline bool has_rse_status() const;
  inline void clear_rse_status();
  static const int kRseStatusFieldNumber = 26;
  inline const ::std::string& rse_status() const;
  inline void set_rse_status(const ::std::string& value);
  inline void set_rse_status(const char* value);
  inline void set_rse_status(const char* value, size_t size);
  inline ::std::string* mutable_rse_status();
  inline ::std::string* release_rse_status();
  inline void set_allocated_rse_status(::std::string* rse_status);

  // optional string ccc_status = 30;
  inline bool has_ccc_status() const;
  inline void clear_ccc_status();
  static const int kCccStatusFieldNumber = 30;
  inline const ::std::string& ccc_status() const;
  inline void set_ccc_status(const ::std::string& value);
  inline void set_ccc_status(const char* value);
  inline void set_ccc_status(const char* value, size_t size);
  inline ::std::string* mutable_ccc_status();
  inline ::std::string* release_ccc_status();
  inline void set_allocated_ccc_status(::std::string* ccc_status);

  // optional string pp_status = 31;
  inline bool has_pp_status() const;
  inline void clear_pp_status();
  static const int kPpStatusFieldNumber = 31;
  inline const ::std::string& pp_status() const;
  inline void set_pp_status(const ::std::string& value);
  inline void set_pp_status(const char* value);
  inline void set_pp_status(const char* value, size_t size);
  inline ::std::string* mutable_pp_status();
  inline ::std::string* release_pp_status();
  inline void set_allocated_pp_status(::std::string* pp_status);

  // optional string gps = 27;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 27;
  inline const ::std::string& gps() const;
  inline void set_gps(const ::std::string& value);
  inline void set_gps(const char* value);
  inline void set_gps(const char* value, size_t size);
  inline ::std::string* mutable_gps();
  inline ::std::string* release_gps();
  inline void set_allocated_gps(::std::string* gps);

  // optional double mag_front = 28;
  inline bool has_mag_front() const;
  inline void clear_mag_front();
  static const int kMagFrontFieldNumber = 28;
  inline double mag_front() const;
  inline void set_mag_front(double value);

  // optional double mag_rear = 29;
  inline bool has_mag_rear() const;
  inline void clear_mag_rear();
  static const int kMagRearFieldNumber = 29;
  inline double mag_rear() const;
  inline void set_mag_rear(double value);

  // optional string monitor_status = 32;
  inline bool has_monitor_status() const;
  inline void clear_monitor_status();
  static const int kMonitorStatusFieldNumber = 32;
  inline const ::std::string& monitor_status() const;
  inline void set_monitor_status(const ::std::string& value);
  inline void set_monitor_status(const char* value);
  inline void set_monitor_status(const char* value, size_t size);
  inline ::std::string* mutable_monitor_status();
  inline ::std::string* release_monitor_status();
  inline void set_allocated_monitor_status(::std::string* monitor_status);

  // @@protoc_insertion_point(class_scope:ocu.Status)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_fsm_actuator();
  inline void clear_has_fsm_actuator();
  inline void set_has_fsm_status();
  inline void clear_has_fsm_status();
  inline void set_has_base_status();
  inline void clear_has_base_status();
  inline void set_has_actuator_status();
  inline void clear_has_actuator_status();
  inline void set_has_rse_status();
  inline void clear_has_rse_status();
  inline void set_has_ccc_status();
  inline void clear_has_ccc_status();
  inline void set_has_pp_status();
  inline void clear_has_pp_status();
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_mag_front();
  inline void clear_has_mag_front();
  inline void set_has_mag_rear();
  inline void clear_has_mag_rear();
  inline void set_has_monitor_status();
  inline void clear_has_monitor_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 seq_;
  ::std::string* fsm_actuator_;
  ::std::string* fsm_status_;
  ::std::string* base_status_;
  ::std::string* actuator_status_;
  ::std::string* rse_status_;
  ::std::string* ccc_status_;
  ::std::string* pp_status_;
  ::std::string* gps_;
  double mag_front_;
  double mag_rear_;
  ::std::string* monitor_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_ocu_2eproto();
  friend void protobuf_AssignDesc_ocu_2eproto();
  friend void protobuf_ShutdownFile_ocu_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::uint64 seq() const;
  inline void set_seq(::google::protobuf::uint64 value);

  // optional string pp_map_file = 2;
  inline bool has_pp_map_file() const;
  inline void clear_pp_map_file();
  static const int kPpMapFileFieldNumber = 2;
  inline const ::std::string& pp_map_file() const;
  inline void set_pp_map_file(const ::std::string& value);
  inline void set_pp_map_file(const char* value);
  inline void set_pp_map_file(const char* value, size_t size);
  inline ::std::string* mutable_pp_map_file();
  inline ::std::string* release_pp_map_file();
  inline void set_allocated_pp_map_file(::std::string* pp_map_file);

  // optional double pp_goal_lat = 3;
  inline bool has_pp_goal_lat() const;
  inline void clear_pp_goal_lat();
  static const int kPpGoalLatFieldNumber = 3;
  inline double pp_goal_lat() const;
  inline void set_pp_goal_lat(double value);

  // optional double pp_goal_lon = 4;
  inline bool has_pp_goal_lon() const;
  inline void clear_pp_goal_lon();
  static const int kPpGoalLonFieldNumber = 4;
  inline double pp_goal_lon() const;
  inline void set_pp_goal_lon(double value);

  // optional double pp_goal_alt = 5;
  inline bool has_pp_goal_alt() const;
  inline void clear_pp_goal_alt();
  static const int kPpGoalAltFieldNumber = 5;
  inline double pp_goal_alt() const;
  inline void set_pp_goal_alt(double value);

  // optional string joy = 6;
  inline bool has_joy() const;
  inline void clear_joy();
  static const int kJoyFieldNumber = 6;
  inline const ::std::string& joy() const;
  inline void set_joy(const ::std::string& value);
  inline void set_joy(const char* value);
  inline void set_joy(const char* value, size_t size);
  inline ::std::string* mutable_joy();
  inline ::std::string* release_joy();
  inline void set_allocated_joy(::std::string* joy);

  // optional double ccc_speed = 7;
  inline bool has_ccc_speed() const;
  inline void clear_ccc_speed();
  static const int kCccSpeedFieldNumber = 7;
  inline double ccc_speed() const;
  inline void set_ccc_speed(double value);

  // optional bool select_joy = 8;
  inline bool has_select_joy() const;
  inline void clear_select_joy();
  static const int kSelectJoyFieldNumber = 8;
  inline bool select_joy() const;
  inline void set_select_joy(bool value);

  // optional bool select_ccc = 9;
  inline bool has_select_ccc() const;
  inline void clear_select_ccc();
  static const int kSelectCccFieldNumber = 9;
  inline bool select_ccc() const;
  inline void set_select_ccc(bool value);

  // optional bool select_pp = 10;
  inline bool has_select_pp() const;
  inline void clear_select_pp();
  static const int kSelectPpFieldNumber = 10;
  inline bool select_pp() const;
  inline void set_select_pp(bool value);

  // optional .ocu.Map map = 21;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 21;
  inline const ::ocu::Map& map() const;
  inline ::ocu::Map* mutable_map();
  inline ::ocu::Map* release_map();
  inline void set_allocated_map(::ocu::Map* map);

  // @@protoc_insertion_point(class_scope:ocu.Command)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_pp_map_file();
  inline void clear_has_pp_map_file();
  inline void set_has_pp_goal_lat();
  inline void clear_has_pp_goal_lat();
  inline void set_has_pp_goal_lon();
  inline void clear_has_pp_goal_lon();
  inline void set_has_pp_goal_alt();
  inline void clear_has_pp_goal_alt();
  inline void set_has_joy();
  inline void clear_has_joy();
  inline void set_has_ccc_speed();
  inline void clear_has_ccc_speed();
  inline void set_has_select_joy();
  inline void clear_has_select_joy();
  inline void set_has_select_ccc();
  inline void clear_has_select_ccc();
  inline void set_has_select_pp();
  inline void clear_has_select_pp();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 seq_;
  ::std::string* pp_map_file_;
  double pp_goal_lat_;
  double pp_goal_lon_;
  double pp_goal_alt_;
  ::std::string* joy_;
  double ccc_speed_;
  ::ocu::Map* map_;
  bool select_joy_;
  bool select_ccc_;
  bool select_pp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ocu_2eproto();
  friend void protobuf_AssignDesc_ocu_2eproto();
  friend void protobuf_ShutdownFile_ocu_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 17;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 17;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 18;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 18;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 19;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 19;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:ocu.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ocu_2eproto();
  friend void protobuf_AssignDesc_ocu_2eproto();
  friend void protobuf_ShutdownFile_ocu_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ocu.Point point = 20;
  inline int point_size() const;
  inline void clear_point();
  static const int kPointFieldNumber = 20;
  inline const ::ocu::Point& point(int index) const;
  inline ::ocu::Point* mutable_point(int index);
  inline ::ocu::Point* add_point();
  inline const ::google::protobuf::RepeatedPtrField< ::ocu::Point >&
      point() const;
  inline ::google::protobuf::RepeatedPtrField< ::ocu::Point >*
      mutable_point();

  // @@protoc_insertion_point(class_scope:ocu.Map)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ocu::Point > point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ocu_2eproto();
  friend void protobuf_AssignDesc_ocu_2eproto();
  friend void protobuf_ShutdownFile_ocu_2eproto();

  void InitAsDefaultInstance();
  static Map* default_instance_;
};
// ===================================================================


// ===================================================================

// Status

// required uint64 seq = 21;
inline bool Status::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_seq() {
  seq_ = GOOGLE_ULONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::uint64 Status::seq() const {
  return seq_;
}
inline void Status::set_seq(::google::protobuf::uint64 value) {
  set_has_seq();
  seq_ = value;
}

// optional string fsm_actuator = 22;
inline bool Status::has_fsm_actuator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_fsm_actuator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_fsm_actuator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_fsm_actuator() {
  if (fsm_actuator_ != &::google::protobuf::internal::kEmptyString) {
    fsm_actuator_->clear();
  }
  clear_has_fsm_actuator();
}
inline const ::std::string& Status::fsm_actuator() const {
  return *fsm_actuator_;
}
inline void Status::set_fsm_actuator(const ::std::string& value) {
  set_has_fsm_actuator();
  if (fsm_actuator_ == &::google::protobuf::internal::kEmptyString) {
    fsm_actuator_ = new ::std::string;
  }
  fsm_actuator_->assign(value);
}
inline void Status::set_fsm_actuator(const char* value) {
  set_has_fsm_actuator();
  if (fsm_actuator_ == &::google::protobuf::internal::kEmptyString) {
    fsm_actuator_ = new ::std::string;
  }
  fsm_actuator_->assign(value);
}
inline void Status::set_fsm_actuator(const char* value, size_t size) {
  set_has_fsm_actuator();
  if (fsm_actuator_ == &::google::protobuf::internal::kEmptyString) {
    fsm_actuator_ = new ::std::string;
  }
  fsm_actuator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_fsm_actuator() {
  set_has_fsm_actuator();
  if (fsm_actuator_ == &::google::protobuf::internal::kEmptyString) {
    fsm_actuator_ = new ::std::string;
  }
  return fsm_actuator_;
}
inline ::std::string* Status::release_fsm_actuator() {
  clear_has_fsm_actuator();
  if (fsm_actuator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fsm_actuator_;
    fsm_actuator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_fsm_actuator(::std::string* fsm_actuator) {
  if (fsm_actuator_ != &::google::protobuf::internal::kEmptyString) {
    delete fsm_actuator_;
  }
  if (fsm_actuator) {
    set_has_fsm_actuator();
    fsm_actuator_ = fsm_actuator;
  } else {
    clear_has_fsm_actuator();
    fsm_actuator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fsm_status = 23;
inline bool Status::has_fsm_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_fsm_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_fsm_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_fsm_status() {
  if (fsm_status_ != &::google::protobuf::internal::kEmptyString) {
    fsm_status_->clear();
  }
  clear_has_fsm_status();
}
inline const ::std::string& Status::fsm_status() const {
  return *fsm_status_;
}
inline void Status::set_fsm_status(const ::std::string& value) {
  set_has_fsm_status();
  if (fsm_status_ == &::google::protobuf::internal::kEmptyString) {
    fsm_status_ = new ::std::string;
  }
  fsm_status_->assign(value);
}
inline void Status::set_fsm_status(const char* value) {
  set_has_fsm_status();
  if (fsm_status_ == &::google::protobuf::internal::kEmptyString) {
    fsm_status_ = new ::std::string;
  }
  fsm_status_->assign(value);
}
inline void Status::set_fsm_status(const char* value, size_t size) {
  set_has_fsm_status();
  if (fsm_status_ == &::google::protobuf::internal::kEmptyString) {
    fsm_status_ = new ::std::string;
  }
  fsm_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_fsm_status() {
  set_has_fsm_status();
  if (fsm_status_ == &::google::protobuf::internal::kEmptyString) {
    fsm_status_ = new ::std::string;
  }
  return fsm_status_;
}
inline ::std::string* Status::release_fsm_status() {
  clear_has_fsm_status();
  if (fsm_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fsm_status_;
    fsm_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_fsm_status(::std::string* fsm_status) {
  if (fsm_status_ != &::google::protobuf::internal::kEmptyString) {
    delete fsm_status_;
  }
  if (fsm_status) {
    set_has_fsm_status();
    fsm_status_ = fsm_status;
  } else {
    clear_has_fsm_status();
    fsm_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string base_status = 24;
inline bool Status::has_base_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Status::set_has_base_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Status::clear_has_base_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Status::clear_base_status() {
  if (base_status_ != &::google::protobuf::internal::kEmptyString) {
    base_status_->clear();
  }
  clear_has_base_status();
}
inline const ::std::string& Status::base_status() const {
  return *base_status_;
}
inline void Status::set_base_status(const ::std::string& value) {
  set_has_base_status();
  if (base_status_ == &::google::protobuf::internal::kEmptyString) {
    base_status_ = new ::std::string;
  }
  base_status_->assign(value);
}
inline void Status::set_base_status(const char* value) {
  set_has_base_status();
  if (base_status_ == &::google::protobuf::internal::kEmptyString) {
    base_status_ = new ::std::string;
  }
  base_status_->assign(value);
}
inline void Status::set_base_status(const char* value, size_t size) {
  set_has_base_status();
  if (base_status_ == &::google::protobuf::internal::kEmptyString) {
    base_status_ = new ::std::string;
  }
  base_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_base_status() {
  set_has_base_status();
  if (base_status_ == &::google::protobuf::internal::kEmptyString) {
    base_status_ = new ::std::string;
  }
  return base_status_;
}
inline ::std::string* Status::release_base_status() {
  clear_has_base_status();
  if (base_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = base_status_;
    base_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_base_status(::std::string* base_status) {
  if (base_status_ != &::google::protobuf::internal::kEmptyString) {
    delete base_status_;
  }
  if (base_status) {
    set_has_base_status();
    base_status_ = base_status;
  } else {
    clear_has_base_status();
    base_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string actuator_status = 25;
inline bool Status::has_actuator_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Status::set_has_actuator_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Status::clear_has_actuator_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Status::clear_actuator_status() {
  if (actuator_status_ != &::google::protobuf::internal::kEmptyString) {
    actuator_status_->clear();
  }
  clear_has_actuator_status();
}
inline const ::std::string& Status::actuator_status() const {
  return *actuator_status_;
}
inline void Status::set_actuator_status(const ::std::string& value) {
  set_has_actuator_status();
  if (actuator_status_ == &::google::protobuf::internal::kEmptyString) {
    actuator_status_ = new ::std::string;
  }
  actuator_status_->assign(value);
}
inline void Status::set_actuator_status(const char* value) {
  set_has_actuator_status();
  if (actuator_status_ == &::google::protobuf::internal::kEmptyString) {
    actuator_status_ = new ::std::string;
  }
  actuator_status_->assign(value);
}
inline void Status::set_actuator_status(const char* value, size_t size) {
  set_has_actuator_status();
  if (actuator_status_ == &::google::protobuf::internal::kEmptyString) {
    actuator_status_ = new ::std::string;
  }
  actuator_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_actuator_status() {
  set_has_actuator_status();
  if (actuator_status_ == &::google::protobuf::internal::kEmptyString) {
    actuator_status_ = new ::std::string;
  }
  return actuator_status_;
}
inline ::std::string* Status::release_actuator_status() {
  clear_has_actuator_status();
  if (actuator_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actuator_status_;
    actuator_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_actuator_status(::std::string* actuator_status) {
  if (actuator_status_ != &::google::protobuf::internal::kEmptyString) {
    delete actuator_status_;
  }
  if (actuator_status) {
    set_has_actuator_status();
    actuator_status_ = actuator_status;
  } else {
    clear_has_actuator_status();
    actuator_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rse_status = 26;
inline bool Status::has_rse_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Status::set_has_rse_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Status::clear_has_rse_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Status::clear_rse_status() {
  if (rse_status_ != &::google::protobuf::internal::kEmptyString) {
    rse_status_->clear();
  }
  clear_has_rse_status();
}
inline const ::std::string& Status::rse_status() const {
  return *rse_status_;
}
inline void Status::set_rse_status(const ::std::string& value) {
  set_has_rse_status();
  if (rse_status_ == &::google::protobuf::internal::kEmptyString) {
    rse_status_ = new ::std::string;
  }
  rse_status_->assign(value);
}
inline void Status::set_rse_status(const char* value) {
  set_has_rse_status();
  if (rse_status_ == &::google::protobuf::internal::kEmptyString) {
    rse_status_ = new ::std::string;
  }
  rse_status_->assign(value);
}
inline void Status::set_rse_status(const char* value, size_t size) {
  set_has_rse_status();
  if (rse_status_ == &::google::protobuf::internal::kEmptyString) {
    rse_status_ = new ::std::string;
  }
  rse_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_rse_status() {
  set_has_rse_status();
  if (rse_status_ == &::google::protobuf::internal::kEmptyString) {
    rse_status_ = new ::std::string;
  }
  return rse_status_;
}
inline ::std::string* Status::release_rse_status() {
  clear_has_rse_status();
  if (rse_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rse_status_;
    rse_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_rse_status(::std::string* rse_status) {
  if (rse_status_ != &::google::protobuf::internal::kEmptyString) {
    delete rse_status_;
  }
  if (rse_status) {
    set_has_rse_status();
    rse_status_ = rse_status;
  } else {
    clear_has_rse_status();
    rse_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ccc_status = 30;
inline bool Status::has_ccc_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Status::set_has_ccc_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Status::clear_has_ccc_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Status::clear_ccc_status() {
  if (ccc_status_ != &::google::protobuf::internal::kEmptyString) {
    ccc_status_->clear();
  }
  clear_has_ccc_status();
}
inline const ::std::string& Status::ccc_status() const {
  return *ccc_status_;
}
inline void Status::set_ccc_status(const ::std::string& value) {
  set_has_ccc_status();
  if (ccc_status_ == &::google::protobuf::internal::kEmptyString) {
    ccc_status_ = new ::std::string;
  }
  ccc_status_->assign(value);
}
inline void Status::set_ccc_status(const char* value) {
  set_has_ccc_status();
  if (ccc_status_ == &::google::protobuf::internal::kEmptyString) {
    ccc_status_ = new ::std::string;
  }
  ccc_status_->assign(value);
}
inline void Status::set_ccc_status(const char* value, size_t size) {
  set_has_ccc_status();
  if (ccc_status_ == &::google::protobuf::internal::kEmptyString) {
    ccc_status_ = new ::std::string;
  }
  ccc_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_ccc_status() {
  set_has_ccc_status();
  if (ccc_status_ == &::google::protobuf::internal::kEmptyString) {
    ccc_status_ = new ::std::string;
  }
  return ccc_status_;
}
inline ::std::string* Status::release_ccc_status() {
  clear_has_ccc_status();
  if (ccc_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ccc_status_;
    ccc_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_ccc_status(::std::string* ccc_status) {
  if (ccc_status_ != &::google::protobuf::internal::kEmptyString) {
    delete ccc_status_;
  }
  if (ccc_status) {
    set_has_ccc_status();
    ccc_status_ = ccc_status;
  } else {
    clear_has_ccc_status();
    ccc_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pp_status = 31;
inline bool Status::has_pp_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Status::set_has_pp_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Status::clear_has_pp_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Status::clear_pp_status() {
  if (pp_status_ != &::google::protobuf::internal::kEmptyString) {
    pp_status_->clear();
  }
  clear_has_pp_status();
}
inline const ::std::string& Status::pp_status() const {
  return *pp_status_;
}
inline void Status::set_pp_status(const ::std::string& value) {
  set_has_pp_status();
  if (pp_status_ == &::google::protobuf::internal::kEmptyString) {
    pp_status_ = new ::std::string;
  }
  pp_status_->assign(value);
}
inline void Status::set_pp_status(const char* value) {
  set_has_pp_status();
  if (pp_status_ == &::google::protobuf::internal::kEmptyString) {
    pp_status_ = new ::std::string;
  }
  pp_status_->assign(value);
}
inline void Status::set_pp_status(const char* value, size_t size) {
  set_has_pp_status();
  if (pp_status_ == &::google::protobuf::internal::kEmptyString) {
    pp_status_ = new ::std::string;
  }
  pp_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_pp_status() {
  set_has_pp_status();
  if (pp_status_ == &::google::protobuf::internal::kEmptyString) {
    pp_status_ = new ::std::string;
  }
  return pp_status_;
}
inline ::std::string* Status::release_pp_status() {
  clear_has_pp_status();
  if (pp_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pp_status_;
    pp_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_pp_status(::std::string* pp_status) {
  if (pp_status_ != &::google::protobuf::internal::kEmptyString) {
    delete pp_status_;
  }
  if (pp_status) {
    set_has_pp_status();
    pp_status_ = pp_status;
  } else {
    clear_has_pp_status();
    pp_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gps = 27;
inline bool Status::has_gps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Status::set_has_gps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Status::clear_has_gps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Status::clear_gps() {
  if (gps_ != &::google::protobuf::internal::kEmptyString) {
    gps_->clear();
  }
  clear_has_gps();
}
inline const ::std::string& Status::gps() const {
  return *gps_;
}
inline void Status::set_gps(const ::std::string& value) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  gps_->assign(value);
}
inline void Status::set_gps(const char* value) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  gps_->assign(value);
}
inline void Status::set_gps(const char* value, size_t size) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  gps_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_gps() {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  return gps_;
}
inline ::std::string* Status::release_gps() {
  clear_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gps_;
    gps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_gps(::std::string* gps) {
  if (gps_ != &::google::protobuf::internal::kEmptyString) {
    delete gps_;
  }
  if (gps) {
    set_has_gps();
    gps_ = gps;
  } else {
    clear_has_gps();
    gps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double mag_front = 28;
inline bool Status::has_mag_front() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Status::set_has_mag_front() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Status::clear_has_mag_front() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Status::clear_mag_front() {
  mag_front_ = 0;
  clear_has_mag_front();
}
inline double Status::mag_front() const {
  return mag_front_;
}
inline void Status::set_mag_front(double value) {
  set_has_mag_front();
  mag_front_ = value;
}

// optional double mag_rear = 29;
inline bool Status::has_mag_rear() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Status::set_has_mag_rear() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Status::clear_has_mag_rear() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Status::clear_mag_rear() {
  mag_rear_ = 0;
  clear_has_mag_rear();
}
inline double Status::mag_rear() const {
  return mag_rear_;
}
inline void Status::set_mag_rear(double value) {
  set_has_mag_rear();
  mag_rear_ = value;
}

// optional string monitor_status = 32;
inline bool Status::has_monitor_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Status::set_has_monitor_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Status::clear_has_monitor_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Status::clear_monitor_status() {
  if (monitor_status_ != &::google::protobuf::internal::kEmptyString) {
    monitor_status_->clear();
  }
  clear_has_monitor_status();
}
inline const ::std::string& Status::monitor_status() const {
  return *monitor_status_;
}
inline void Status::set_monitor_status(const ::std::string& value) {
  set_has_monitor_status();
  if (monitor_status_ == &::google::protobuf::internal::kEmptyString) {
    monitor_status_ = new ::std::string;
  }
  monitor_status_->assign(value);
}
inline void Status::set_monitor_status(const char* value) {
  set_has_monitor_status();
  if (monitor_status_ == &::google::protobuf::internal::kEmptyString) {
    monitor_status_ = new ::std::string;
  }
  monitor_status_->assign(value);
}
inline void Status::set_monitor_status(const char* value, size_t size) {
  set_has_monitor_status();
  if (monitor_status_ == &::google::protobuf::internal::kEmptyString) {
    monitor_status_ = new ::std::string;
  }
  monitor_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_monitor_status() {
  set_has_monitor_status();
  if (monitor_status_ == &::google::protobuf::internal::kEmptyString) {
    monitor_status_ = new ::std::string;
  }
  return monitor_status_;
}
inline ::std::string* Status::release_monitor_status() {
  clear_has_monitor_status();
  if (monitor_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monitor_status_;
    monitor_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Status::set_allocated_monitor_status(::std::string* monitor_status) {
  if (monitor_status_ != &::google::protobuf::internal::kEmptyString) {
    delete monitor_status_;
  }
  if (monitor_status) {
    set_has_monitor_status();
    monitor_status_ = monitor_status;
  } else {
    clear_has_monitor_status();
    monitor_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command

// required uint64 seq = 1;
inline bool Command::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_seq() {
  seq_ = GOOGLE_ULONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::uint64 Command::seq() const {
  return seq_;
}
inline void Command::set_seq(::google::protobuf::uint64 value) {
  set_has_seq();
  seq_ = value;
}

// optional string pp_map_file = 2;
inline bool Command::has_pp_map_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_pp_map_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_pp_map_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_pp_map_file() {
  if (pp_map_file_ != &::google::protobuf::internal::kEmptyString) {
    pp_map_file_->clear();
  }
  clear_has_pp_map_file();
}
inline const ::std::string& Command::pp_map_file() const {
  return *pp_map_file_;
}
inline void Command::set_pp_map_file(const ::std::string& value) {
  set_has_pp_map_file();
  if (pp_map_file_ == &::google::protobuf::internal::kEmptyString) {
    pp_map_file_ = new ::std::string;
  }
  pp_map_file_->assign(value);
}
inline void Command::set_pp_map_file(const char* value) {
  set_has_pp_map_file();
  if (pp_map_file_ == &::google::protobuf::internal::kEmptyString) {
    pp_map_file_ = new ::std::string;
  }
  pp_map_file_->assign(value);
}
inline void Command::set_pp_map_file(const char* value, size_t size) {
  set_has_pp_map_file();
  if (pp_map_file_ == &::google::protobuf::internal::kEmptyString) {
    pp_map_file_ = new ::std::string;
  }
  pp_map_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_pp_map_file() {
  set_has_pp_map_file();
  if (pp_map_file_ == &::google::protobuf::internal::kEmptyString) {
    pp_map_file_ = new ::std::string;
  }
  return pp_map_file_;
}
inline ::std::string* Command::release_pp_map_file() {
  clear_has_pp_map_file();
  if (pp_map_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pp_map_file_;
    pp_map_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_pp_map_file(::std::string* pp_map_file) {
  if (pp_map_file_ != &::google::protobuf::internal::kEmptyString) {
    delete pp_map_file_;
  }
  if (pp_map_file) {
    set_has_pp_map_file();
    pp_map_file_ = pp_map_file;
  } else {
    clear_has_pp_map_file();
    pp_map_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double pp_goal_lat = 3;
inline bool Command::has_pp_goal_lat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_pp_goal_lat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_pp_goal_lat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_pp_goal_lat() {
  pp_goal_lat_ = 0;
  clear_has_pp_goal_lat();
}
inline double Command::pp_goal_lat() const {
  return pp_goal_lat_;
}
inline void Command::set_pp_goal_lat(double value) {
  set_has_pp_goal_lat();
  pp_goal_lat_ = value;
}

// optional double pp_goal_lon = 4;
inline bool Command::has_pp_goal_lon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_pp_goal_lon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_pp_goal_lon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_pp_goal_lon() {
  pp_goal_lon_ = 0;
  clear_has_pp_goal_lon();
}
inline double Command::pp_goal_lon() const {
  return pp_goal_lon_;
}
inline void Command::set_pp_goal_lon(double value) {
  set_has_pp_goal_lon();
  pp_goal_lon_ = value;
}

// optional double pp_goal_alt = 5;
inline bool Command::has_pp_goal_alt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_pp_goal_alt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_pp_goal_alt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_pp_goal_alt() {
  pp_goal_alt_ = 0;
  clear_has_pp_goal_alt();
}
inline double Command::pp_goal_alt() const {
  return pp_goal_alt_;
}
inline void Command::set_pp_goal_alt(double value) {
  set_has_pp_goal_alt();
  pp_goal_alt_ = value;
}

// optional string joy = 6;
inline bool Command::has_joy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_joy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_joy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_joy() {
  if (joy_ != &::google::protobuf::internal::kEmptyString) {
    joy_->clear();
  }
  clear_has_joy();
}
inline const ::std::string& Command::joy() const {
  return *joy_;
}
inline void Command::set_joy(const ::std::string& value) {
  set_has_joy();
  if (joy_ == &::google::protobuf::internal::kEmptyString) {
    joy_ = new ::std::string;
  }
  joy_->assign(value);
}
inline void Command::set_joy(const char* value) {
  set_has_joy();
  if (joy_ == &::google::protobuf::internal::kEmptyString) {
    joy_ = new ::std::string;
  }
  joy_->assign(value);
}
inline void Command::set_joy(const char* value, size_t size) {
  set_has_joy();
  if (joy_ == &::google::protobuf::internal::kEmptyString) {
    joy_ = new ::std::string;
  }
  joy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_joy() {
  set_has_joy();
  if (joy_ == &::google::protobuf::internal::kEmptyString) {
    joy_ = new ::std::string;
  }
  return joy_;
}
inline ::std::string* Command::release_joy() {
  clear_has_joy();
  if (joy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = joy_;
    joy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_joy(::std::string* joy) {
  if (joy_ != &::google::protobuf::internal::kEmptyString) {
    delete joy_;
  }
  if (joy) {
    set_has_joy();
    joy_ = joy;
  } else {
    clear_has_joy();
    joy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double ccc_speed = 7;
inline bool Command::has_ccc_speed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_ccc_speed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_ccc_speed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_ccc_speed() {
  ccc_speed_ = 0;
  clear_has_ccc_speed();
}
inline double Command::ccc_speed() const {
  return ccc_speed_;
}
inline void Command::set_ccc_speed(double value) {
  set_has_ccc_speed();
  ccc_speed_ = value;
}

// optional bool select_joy = 8;
inline bool Command::has_select_joy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command::set_has_select_joy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command::clear_has_select_joy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command::clear_select_joy() {
  select_joy_ = false;
  clear_has_select_joy();
}
inline bool Command::select_joy() const {
  return select_joy_;
}
inline void Command::set_select_joy(bool value) {
  set_has_select_joy();
  select_joy_ = value;
}

// optional bool select_ccc = 9;
inline bool Command::has_select_ccc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command::set_has_select_ccc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command::clear_has_select_ccc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command::clear_select_ccc() {
  select_ccc_ = false;
  clear_has_select_ccc();
}
inline bool Command::select_ccc() const {
  return select_ccc_;
}
inline void Command::set_select_ccc(bool value) {
  set_has_select_ccc();
  select_ccc_ = value;
}

// optional bool select_pp = 10;
inline bool Command::has_select_pp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command::set_has_select_pp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command::clear_has_select_pp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command::clear_select_pp() {
  select_pp_ = false;
  clear_has_select_pp();
}
inline bool Command::select_pp() const {
  return select_pp_;
}
inline void Command::set_select_pp(bool value) {
  set_has_select_pp();
  select_pp_ = value;
}

// optional .ocu.Map map = 21;
inline bool Command::has_map() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Command::set_has_map() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Command::clear_has_map() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Command::clear_map() {
  if (map_ != NULL) map_->::ocu::Map::Clear();
  clear_has_map();
}
inline const ::ocu::Map& Command::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::ocu::Map* Command::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::ocu::Map;
  return map_;
}
inline ::ocu::Map* Command::release_map() {
  clear_has_map();
  ::ocu::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void Command::set_allocated_map(::ocu::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// -------------------------------------------------------------------

// Point

// required double x = 17;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 18;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 19;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Map

// repeated .ocu.Point point = 20;
inline int Map::point_size() const {
  return point_.size();
}
inline void Map::clear_point() {
  point_.Clear();
}
inline const ::ocu::Point& Map::point(int index) const {
  return point_.Get(index);
}
inline ::ocu::Point* Map::mutable_point(int index) {
  return point_.Mutable(index);
}
inline ::ocu::Point* Map::add_point() {
  return point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ocu::Point >&
Map::point() const {
  return point_;
}
inline ::google::protobuf::RepeatedPtrField< ::ocu::Point >*
Map::mutable_point() {
  return &point_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ocu

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ocu_2eproto__INCLUDED
